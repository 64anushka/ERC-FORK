---
eip: 7092
title: Financial Bonds
description: Represents debt issued by entities to investors.
author: Samuel Gwlanold Edoumou (@Edoumou)
discussions-to: https://ethereum-magicians.org/t/financial-bonds/14461
status: Review
type: Standards Track
category: ERC
created: 2023-05-28
requires: 165
---

## Abstract

This proposal introduces fixed-income financial bonds with key characteristics defined to facilitate bond issuance in the primary market and enable buying or selling bonds in the secondary market. The standard also provides cross-chain functionalities for bonds operations and management accross multiple blockchains.

## Motivation

Fixed-income instruments are a widely utilized asset class for corporations and other entities raising funds. However, transitioning to tokenized bonds is challenging due to existing standards like [ERC-3475](./erc-3475.md), which introduces unfamiliar concepts and leads to unnecessary gas consumption. Additionally, the lack of named variables like coupon, maturity date, and principal, makes it difficult to implement ERC-3475 since developers need to remember which metadata is assigned to each parameter.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

**Every contract compliant with this ERC MUST implement the following Token Interface as well as the [ERC-165](./erc-165.md) interface:**

A detailed description of the functions can be found [here](../assets/erc-7092/IERC7092.sol)

```solidity
// SPDX-License-Identifier: CC0-1.0
pragma solidity ^0.8.0;

/**
* @title ERC-7092 Financial Bonds Standard
*/
interface IERC7092 /** is ERC165 */ {
    // events
    event Transfer(address indexed _from, address indexed _to, uint256 _amount);
    event Approval(address indexed _owner, address indexed _spender, uint256 _amount);
    event TransferBatch(address[] _from, address[] _to, uint256[] _amount);
    event ApprovalBatch(address indexed _owner, address[] _spender, uint256[] _amount);

    // getter functions
    function isin() external view returns(string memory);
    function name() external view returns(string memory);
    function symbol() external view returns(string memory);
    function currency() external view returns(address);
    function denomination() external view returns(uint256);
    function issueVolume() external view returns(uint256);
    function couponRate() external view returns(uint256);
    function issueDate() external view returns(uint256);
    function maturityDate() external view returns(uint256);
    function principalOf(address _account) external view returns(uint256);
    function allowance(address _owner, address _spender) external view returns(uint256);

    // setter functions
    function approve(address _spender, uint256 _amount) external returns(bool);
    function decreaseAllowance(address _spender, uint256 _amount) external;
    function transfer(address _to, uint256 _amount, bytes calldata _data) external returns(bool);
    function transferFrom(address _from, address _to, uint256 _amount, bytes calldata _data) external returns(bool);

    // batch functions
    function batchApprove(address[] calldata _spender, uint256[] calldata _amount) external returns(bool);
    function batchDecreaseAllowance(address[] calldata _spender, uint256[] calldata _amount) external;
    function batchTransfer(address[] calldata _to, uint256[] calldata _amount, bytes[] calldata _data) external returns(bool);
    function batchTransferFrom(address[] calldata _from, address[] calldata _to, uint256[] calldata _amount, bytes[] calldata _data) external returns(bool);
}
```

### Additional bond parameters Interface

Functions in the `IERC7092ESG` interface are OPTIONAL. This interface MAY be used to improve the standard usability.

- The `currencyOfCoupon` The currency used for coupon payment may be different from the currency used to repay the principal
- The `couponType` MAY be employed to signify the interest rate that the issuer has committed to paying to investors, which may take various forms such as zero coupon, fixed rate, floating rate, and more.
- The `couponFrequency` refers to how often the bond pays interest to its bondholders, and is typically expressed in terms of time periods, such as: Annual, Semi-Annual, Quarterly, or Monthly.
- The `dayCountBasis` is used to calculate the accrued interest on a bond between two coupon payment dates or other specific periods. Some of the day count basis are: Actual/Actual, 30/360, Actual/360, Actual/365, or 30/365

A detailed description of the functions can be found [here](../assets/erc-7092/IERC7092Batch.sol)

```solidity
// SPDX-License-Identifier: CC0-1.0
pragma solidity ^0.8.0;

interface IERC7092ESG /** is ERC165 */ {
    function decimals() external view returns(uint8);
    function currencyOfCoupon() external view returns(address);
    function couponType() external view returns(uint8);
    function couponFrequency() external view returns(uint256);
    function dayCountBasis() external view returns(uint8);
}
```

### Cross-chain Interface

The standard permits the implementation of the `IERC7092CrossChain` interface for cross-chain management of bond tokens. This interface is OPTIONAL and may be used by applications to allow cross-chain transactions. Any function initiating a cross-chain transaction MUST explicitly define the destination chain identifier `destinationChainID` and specify the target smart contract `destinationContract`.

A detailed description of the functions can be found [here](../assets/erc-7092/IERC7092CrossChain.sol)

```solidity
// SPDX-License-Identifier: CC0-1.0
pragma solidity ^0.8.0;

interface IERC7092CrossChain /** is ERC165 */ {
    // events
    event CrossChainTransfer(address indexed _from, address indexed _to, uint256 _amount, bytes32 _destinationChainID);
    event CrossChainTransferBatch(address[] _from, address[] _to, uint256[] _amount, bytes32[] _destinationChainID);
    event CrossChainApproval(address indexed _owner, address indexed _spender, uint256 _amount, bytes32 _destinationChainID);
    event CrossChainApprovalBatch(address indexed _owner, address[] _spender, uint256[] _amount, bytes32[] _destinationChainID);

    // functions
    function crossChainApprove(address _spender, uint256 _amount, bytes32 _destinationChainID, address _destinationContract) external returns(bool);
    function crossChainBatchApprove(address[] calldata _spender, uint256[] calldata _amount, bytes32[] calldata _destinationChainID, address[] calldata _destinationContract) external returns(bool);
    function crossChainDecreaseAllowance(address _spender, uint256 _amount, bytes32 _destinationChainID, address _destinationContract) external;
    function crossChainBatchDecreaseAllowance(address[] calldata _spender, uint256[] calldata _amount, bytes32[] calldata _destinationChainID, address[] calldata _destinationContract) external;
    function crossChainTransfer(address _to, uint256 _amount, bytes calldata _data, bytes32 _destinationChainID, address _destinationContract) external returns(bool);
    function crossChainBatchTransfer(address[] calldata _to, uint256[] calldata _amount, bytes[] calldata _data, bytes32[] calldata _destinationChainID, address[] calldata _destinationContract) external returns(bool);
    function crossChainTransferFrom(address _from, address _to, uint256 _amount, bytes calldata _data, bytes32 _destinationChainID, address _destinationContract) external returns(bool);
    function crossChainBatchTransferFrom(address[] calldata _from, address[] calldata _to, uint256[] calldata _amount, bytes[] calldata _data, bytes32[] calldata _destinationChainID, address[] calldata _destinationContract) external returns(bool);
}
```

## Rationale

The design of this ERC aims to simplify the migration to tokenized bonds by maintaining consistency with traditional bond standards. This approach allows fixed-income instruments to be represented as on-chain tokens, manageable through wallets, and utilized by applications like decentralized exchanges, while avoiding the complexities and inefficiencies associated with other standards. This ERC facilitates the creation of new bond tokens with characteristics akin to traditional bonds, enhancing accessibility, liquidity, and cost-efficiency in bond trading and management.

The use of traditional finance terminology, like `issueVolume` and `principalOf`, is aimed at maintaining consistency with traditional bond language, which eases the adaptation for traditional entities.

### Total Supply and Account Balance

The `totalSupply` and `balanceOf` functions are not defined as they can be derived from `issueVolume` and `principalOf`, and `denomination`. However, these functions can be be added in any contract implementing this standard, ensuring the proper relationship between these values.

```solidity
    function totalSupply() external view returns(uint256) {
        return issueVolume() / denomination();
    }

    function balance0f(account) external view returns(uint256) {
        return principal(account) / denomination();
    }
```

## Backwards Compatibility

This ERC SHOULD NOT extend existing standards like [ERC-20](./erc-20.md) or [ERC-1155](./erc-1155.md) due to the absence of certain functions like `totalSupply` or `balanceOf`. A pure implementation of this standard is RECOMMENDED for issuing tokenized bonds, as any hybrid solution with other mentioned standards SHOULD fail.


## Reference Implementation

The complete Reference Implementation can be found [here](../assets/erc-7092/ERC7092.sol).

Bonds with embedded options like callable, puttable, or convertible bonds can be created by inheriting from the reference [ERC-7092](../assets/erc-7092/ERC7092.sol) that integrates the proposed interface.

### CALLABLE BONDS:

```solidity
pragma solidity ^0.8.0;

import 'ERC7092.sol';

contract ERC7092Callable is ERC7092 {
    // WRITE THE LOGIC TO ALLOW THE ISSUER TO CALL BONDS
    // STATE VARIABLES AND FUNCTIONS NEEDED
    
    /**
    * @notice call bonds owned by `_investor`
    *         MUST be called by the issuer only
    */
    function call(address _investor) public {
        require(msg.sender == _issuer[bondISIN].issuerAddress, "ERC7092Callable: ONLY_ISSUER");
        require(_principals[_investor] > 0, "ERC7092Callable: NO_BONDS");
        require(block.timestamp < _bond[bondISIN].maturityDate, "ERC7092Callable: BOND_MATURED");
        
        uint256 principal =  _principals[_investor];
        _principals[_investor] = 0;
        
        // ADD LOGIC HERE
    }
}
```

### PUTTABLE BONDS:

```solidity
pragma solidity ^0.8.0;

import 'ERC7092.sol';

contract ERC7092Puttable is ERC7092 {
    // WRITE THE LOGIC TO ALLOW INVESTORS TO PUT BONDS
    // STATE VARIABLES AND FUNCTIONS NEEDED
    
    /**
    * @notice put bonds
    *         MUST be called by investors who own bonds
    */
    function put() public {
        require(_principals[msg.sender] > 0, "ERC7092Puttable: ONLY_INVESTORS");
        require(block.timestamp < _bond[bondISIN].maturityDate, "ERC7092Puttable: BOND_MATURED");
        
        uint256 principal =  _principals[msg.sender];
        _principals[msg.sender] = 0;
        
        // ADD LOGIC
    }
}
```

### CONVERTIBLE BONDS:

```solidity
pragma solidity ^0.8.0;

import 'ERC7092.sol';

contract ERC7092Convertible is ERC7092 {
    // WRITE THE LOGIC TO ALLOW INVESTOR OR ISSUER TO CONVERT BONDS TO EQUITY
    // STATE VARIABLES AND FUNCTIONS NEEDED
    
    /**
    * @notice convert bonds to equity. Here we assumed that the investors must convert their bonds to equity
    *         Issuer can also convert invetsors bonds to equity.
    */
    function convert() public {
        require(_principals[msg.sender] > 0, "ERC7092Convertible: ONLY_INVESTORS");
        require(block.timestamp < _bond[bondISIN].maturityDate, "ERC7092Convertible: BOND_MATURED");
        
        uint256 principal =  _principals[msg.sender];
        _principals[msg.sender] = 0;
        
        // ADD LOGIC HERE
    }
}
```

### Identity Registry

This standard is designed specifically for tokenizing bonds. It does not inherently manage information pertaining to bondholders' identities. However, to enhance compliance with regulatory requirements and improve transparency, an identity registry can be added  on top of this standard to store the identity of all authorized investors.

By maintaining an identity registry, issuers can ensure that bond tokens issued under the ERC-7092 standard are transferred only to registered and authorized entities. This practice aligns with regulatory compliance measures and provides a structured way to manage and verify the identity of bondholders. It also helps prevent unauthorized or non-compliant transfers of bond tokens.

## Security Considerations

Implementing this ERC requires careful consideration of security risks related to functions approving operators to manage owner's bonds and functions allowing bond transfers. The use of these functions necessitates robust validation to ensure only the bond owner or approved accounts can call them.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).

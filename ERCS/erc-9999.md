---
eip: 9999
title: ERC-721 Name Registry Extension
description: Add a Time-Limited unique naming registry mechanism to ERC-721 tokens. 
author: Chen Liaoyuan (@chenly)
discussions-to: https://ethereum-magicians.org/t/erc-9999-erc-721-name-registry-extension/19005
status: Draft
type: Standards Track
category: ERC
created: 2024-03-01
requires: 721
---

## Abstract

This standard enhances [ERC-721](./eip-721.md) by giving each token a unique name and an expiry date, allowing other token holders to claim the name once it expires.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

Implementers of this extension **MUST** have all of the following functions:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title INameRegistry
 * @dev Interface for the NameRegistry smart contract.
 * This interface allows interaction with a NameRegistry, 
 * enabling the registration, management, and lookup of names 
 * with associated expiry dates tied to specific tokens.
 */
interface INameRegistry {
    /**
     * @dev Emitted when a token is named.
     * @param tokenId The token ID that is being named.
     * @param newName The new name assigned to the token.
     * @param expiryDate The expiry date of the name registration.
     */
    event TokenNamed(uint256 indexed tokenId, bytes32 newName, uint256 expiryDate);

    /**
     * @dev Emitted when a token with a name is minted.
     * @param to The address of the token recipient.
     * @param tokenId The token ID that is minted.
     * @param name The name assigned to the newly minted token.
     * @param expiryDate The expiry date of the name registration.
     */
    event TokenMintedWithName(address indexed to, uint256 indexed tokenId, bytes32 name, uint256 expiryDate);

    /**
     * @dev Emitted when the name of a token is changed.
     * @param tokenId The token ID whose name is changed.
     * @param oldName The previous name of the token.
     * @param newName The new name assigned to the token.
     * @param expiryDate The expiry date of the new name registration.
     */
    event NameChanged(uint256 indexed tokenId, bytes32 oldName, bytes32 newName, uint256 expiryDate);

    /**
     * @dev Returns the name of the specified token, if the name has not expired.
     * @param tokenId The token ID to query for its name.
     * @return The name of the token, or an empty bytes32 if no name is set or it has expired.
     */
    function nameOf(uint256 tokenId) external view returns (bytes32);

    /**
     * @dev Returns the token ID associated with a given name, if the name registration has not expired.
     * @param _name The name to query for its associated token ID.
     * @return The token ID associated with the name, or zero if no token is found or the name has expired.
     */
    function tokenIdOf(bytes32 _name) external view returns (uint256);

    /**
     * @dev Allows a token owner to set or update the name of their token, subject to a duration for the name's validity.
     * @param tokenId The token ID whose name is to be set or updated.
     * @param _name The new name to assign to the token.
     * @param duration The duration in seconds for which the name is valid, starting from the time of calling this function.
     * Note: The name must be unique and not currently in use by an active (non-expired) registration.
     */
    function setName(uint256 tokenId, bytes32 _name, uint256 duration) external;
}
```

## Rationale

Here are a few design decisions and why they were made:

### Intuitive Token IDs

Current token IDs are predominantly numeric, lacking intuitiveness. The extension of the [ERC-721](./eip-721.md) standard to support Named Tokens aims to facilitate the acceptance and use of this standard within the NFT marketplace. By moving beyond mere numbers to include distinctive names, token IDs can more directly reflect the unique identity or value they represent.

### Expanding NFT Use Cases

By allowing each token to possess a unique name, we unlock new application scenarios in ecosystems built around scarce username resources, such as domain name registration systems. In such scenarios, domain owners can demonstrate ownership directly by holding the corresponding token, thereby broadening the application spectrum and enhancing the value of NFTs.

## Backwards Compatibility

This standard is fully [ERC-721](./eip-721.md) compatible.

## Reference Implementation

```solidity
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";

contract NameRegistry is ERC721 {
    event TokenNamed(uint256 indexed tokenId, bytes32 newName, uint256 expiryDate);
    event TokenMintedWithName(address indexed to, uint256 indexed tokenId, bytes32 name, uint256 expiryDate);
    event NameChanged(uint256 indexed tokenId, bytes32 oldName, bytes32 newName, uint256 expiryDate);

    struct NameRegistration {
        uint256 tokenId;
        uint256 expiryDate;
    }

    mapping(uint256 => bytes32) private _tokenNames;
    mapping(bytes32 => NameRegistration) private _nameRegistrations;
    mapping(uint256 => uint256) private _lastSetNameTime;

    uint256 public constant MAX_DURATION = 10 * 365 days;
    uint256 public constant MIN_SET_NAME_INTERVAL = 1 days;

    constructor() ERC721("NameRegistry", "NRG") {}

    function nameOf(uint256 tokenId) public view returns (bytes32) {
        require(_tokenNames[tokenId] != bytes32(0) && _nameRegistrations[_tokenNames[tokenId]].expiryDate > block.timestamp, "NameRegistry: Name expired or does not exist");
        return _tokenNames[tokenId];
    }

    function tokenIdOf(bytes32 _name) public view returns (uint256) {
        require(_nameRegistrations[_name].expiryDate > block.timestamp, "NameRegistry: Name expired");
        return _nameRegistrations[_name].tokenId;
    }

    function setName(uint256 tokenId, bytes32 _name, uint256 duration) public {
        require(ownerOf(tokenId) == msg.sender, "NameRegistry: Caller is not the token owner");
        require(duration <= MAX_DURATION, "NameRegistry: Duration exceeds maximum limit");
        require(block.timestamp - _lastSetNameTime[tokenId] >= MIN_SET_NAME_INTERVAL, "NameRegistry: Minimum interval not met");
        
        // Check if name is either not registered or expired
        require(_nameRegistrations[_name].expiryDate <= block.timestamp, "NameRegistry: Name already in use and not expired");

        bytes32 oldName = _tokenNames[tokenId];
        uint256 expiryDate = block.timestamp + duration;
        _setTokenName(tokenId, _name, expiryDate);

        if(oldName != bytes32(0)) {
            emit NameChanged(tokenId, oldName, _name, expiryDate);
        } else {
            emit TokenNamed(tokenId, _name, expiryDate);
        }

        _lastSetNameTime[tokenId] = block.timestamp;
    }

    function _mint(address to, uint256 tokenId, bytes32 _name, uint256 duration) internal virtual {
        super._mint(to, tokenId);
        uint256 expiryDate = block.timestamp + duration;
        _setTokenName(tokenId, _name, expiryDate);
        emit TokenMintedWithName(to, tokenId, _name, expiryDate);
    }

    function _setTokenName(uint256 tokenId, bytes32 _name, uint256 expiryDate) internal {
        _tokenNames[tokenId] = _name;
        _nameRegistrations[_name] = NameRegistration(tokenId, expiryDate);
    }
}
```

## Security Considerations

The implementation of minimum intervals for name setting and maximum expiry durations for names prevents abusive behaviors and resource hoarding, deters spam and malicious attacks by limiting rapid, consecutive transactions, and promotes the efficient and equitable use of naming resources. By ensuring that names cannot be monopolized indefinitely and that all actions are rate-limited, these guidelines not only mitigate potential security risks but also foster a more sustainable and fair environment for all participants in the ecosystem.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
---
eip: 7662
title: AI Agent NFTs
description: A specification for NFTs that represent AI Agents.
author: Greg Marlin (@marleymarl)
discussions-to: https://ethereum-magicians.org/t/erc-7662-ai-agent-nfts/19371
status: Draft
type: Standards Track
category: ERC
created: 2024-03-26
requires: 721
---

## Abstract

This proposal introduces a standard for AI agent NFTs. When AI Agents are created and traded as NFTs, it doesn't make sense to put the prompts in the token metadata, therefore it requires a standard custom struct. It also doesn't make sense to store the prompts directly onchain as they can be quite large, therefore this standard proposes they be stored as decentralized storage URLs. This standard also proposes two options on how this data should be made private to the owner of the NFT, with the favored implementation option being encrypting the data using custom contract parameters for decryption that decrypt only to the owner of the NFT. 

## Motivation

The creation and trading of AI Agent NFTs are a natural fit and offer the potential for an entirely new onchain market. This requires some custom data to be embedded in the NFT through a custom struct and this needs to be standardized so that any marketplace or AI Agent management product, among others, know how to create and parse AI Agent NFTs.  


## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.


All ERC-XXXX compliant contracts MUST implement the standard [ERC-721](./eip-721.md) functionality for minting and transferring NFTs, and MUST additionally implement this standard's Agent struct

```solidity
   
struct Agent {
  string name;
  string description;
  string model;
  string userPromptURI;
  string systemPromptURI;
  bool promptsEncrypted;
}
```

and MUST implement the mapping between NFT Token ID and its Agent information.

```solidity
   
mapping(uint => Agent) public Agents;
```

It is RECOMMENDED that this mapping is public and that the URIs for User Prompt and System Prompt are made private through encryption with decryption set to the holder of the NFT via custom contract parameters set during encryption, such as those provided by Lit Protocol. 

It is conceivable to also create an implementation whereby this mapping was set to private and accessed through a custom function that restricted access to the holder of the NFT. This approach would explose the prompts through their urls though, therefore the RECOMMENDED approach is a public mapping and encryption on the URLs. This also has the benefit of publicly exposing the data in the Agent struct to verify name, description and model and that encyrpted URIs for the User Prompt and System Prompt exist. 

All ERC-XXXX compliant contracts MUST implement the mintAgent function

```solidity
   
function mintAgent(address _recipient, string memory _name, string memory _description, string memory _model, string memory _userPromptURI, string memory _systemPromptURI, string memory _imageURI, string memory _category, string memory _tokenURI) public {
        tokenIds++;
        bool _promptsEncrypted = false;
        Agents[tokenIds] = Agent(_name, _description, _model, _userPromptURI, _systemPromptURI, _imageURI, _category, _promptsEncrypted);

        _mint(_recipient, tokenIds);
        collectionIds[_recipient].push(tokenIds);
        _setTokenURI(tokenIds, _tokenURI);
        emit AgentCreated(_name, _description, _model, _category, _recipient, tokenIds);
    }

```

It is RECOMMENDED to implement the following function to encrypt the user prompt in the userPromptURI and the system prompt in the systemPromptURI us the following function: 

```solidity

function addEncryptedPrompts(uint256 _tokenId, string memory _encryptedUserPromptURI, string memory _encryptedSystemPromptURI) public {
        require(ownerOf(_tokenId) == msg.sender, "Sender must be token owner");
        Agent storage agent = Agents[_tokenId];
        agent.userPromptURI = _encryptedUserPromptURI;
        agent.systemPromptURI = _encryptedSystemPromptURI;
        agent.promptsEncrypted = true;
    }

```

It is RECOMMENDED to implement the following events: 

```solidity
event AgentCreated(string name, string description, string model, address recipient, uint256 tokenId)

```

To enable dynamic variables being injected into the User Prompt before being run, any such variables MUST be surrounded with ${} e.g. ${dynamicVariableName} in order that they can be recognized and handled appropriately by programs and systems that will enabled the injection, e.g. web forms and automation systems. 

It is RECOMMENDED to add a data to the [ERC-721](./eip-721.md) standard that makes it easy for e.g. NFT Marketplaces to display data about the AI Agent NFT, i.e. Model, which in turn reveals the platform that is used for the agent, e.g. OpenAI in the case of gpt-4-0125-preview or Anthropic in the case of claude-3-opus-20240229. The standard name and description can be used to display the Agent Name and Agent Description. 

## Rationale

This standard provides a unified way to create and parse AI Agent NFTs. 

This standard codifies the necessary parameters of Name, Description, Model, User Prompt, and System Prompt for creating and using AI Agent NFTs. 

It doesn't make practical sense to store the user and system prompts in an existing [ERC-721](./eip-721.md) as the only place to put would be in the token metadata that is open for anyone to access the prompts without owning the NFT. By storing the prompts in a custom Agent struct and restricting access to the prompts to the holder of the NFT.  One way to do this would be through restricing access to the struct info to the holder of the NFT through a custom function, however since that option still exposes the prompt URIs to the public and thus the data inside them, the recommended method is by encrypting the prompts onchain and tying the decryption of the URLs to the holder of the NFT, using onchain services such as Lit Protocol that enable decryption to be tied to contract parameters such as ownerOf(tokenId).
 

## Backwards Compatibility

The AI Agents NFT standard introduces additional features and data to the standard [ERC-721](./eip-721.md) protocol, aimed at addressing the practical requirements of using NFTs to store, trade and use AI Agents. It is designed to be fully backward-compatible with the original [ERC-721](./eip-721.md) standard.  All existing [ERC-721](./eip-721.md) functions (such as transferFrom, approve, and balanceOf) retain their original functionality and interfaces. Our extension does not modify these core behaviors, ensuring that any [ERC-721](./eip-721.md) compliant wallet or service can interact with these tokens without modifications.

### Reference Implementation

This is being currently implemented in a CEO AI product for creating, managing and using AI Agents Onchain through a DApp interface. In this implementation, Lit Protocol is being used to encrypt the prompts using custom EVMContractParameters that only decrypt for the holder of the NFT and using Arweave to store the URLs of this encrypted data. To facilitate that and make DApp handling easier, some parameters were added to Agent and the addEncryptedPrompts function is added that enables adding the encrypted prompt URIs after first minting the NFT (as the tokenId of the NFT is needed for setting the encryption/decryption conditions)

```solidity

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/interfaces/IERC721.sol";
import "./lib/FactoryOperatorable.sol";

contract ERC7662 is FactoryOperatorable, ERC721URIStorage {

    uint256 public tokenIds;

    //NFT Base URI
    string public baseURI;


    struct Agent { 
        string name;
        string description;
        string model;
        string userPromptURI;
        string systemPromptURI;
        string imageURI;
        string category;
        bool promptsEncrypted;
    }

    mapping(address => uint256[]) public collectionIds;
    mapping(uint => Agent) public Agents;

    event AgentCreated(string name, string description, string model, string category, address recipient, uint256 tokenId);
    
    constructor( 
        string memory collectionBaseURI,
        address admin,
        address operator) ERC721("Agent NFTs", "AGENTS") FactoryOperatorable(admin, operator) {

        baseURI = collectionBaseURI;

    }

     /**
     * @dev Override supportInterface.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721) returns (bool) {
        return super.supportsInterface(interfaceId);
    }


    /**
     * @dev Mint an Agent NFT and attach its data to the token id
     *
     * @param _recipient address to receive NFT
     * @param _name string Name of the Agent
     * @param _description string Description of the Agent
     * @param _model string AI Model of the Agent
     * @param _userPromptURI string URI of the Agent's User Prompt
     * @param _systemPromptURI string URI of the Agent's System Prompt
     * @param _imageURI string URI of the NFT image
     * @param _category string Category of Agent
     * @param _tokenURI string URI of the NFT
     *
     * Emits an AgentCreated event.
     */
    function mintAgent(address _recipient, string memory _name, string memory _description, string memory _model, string memory _userPromptURI, string memory _systemPromptURI, string memory _imageURI, string memory _category, string memory _tokenURI) public {
        tokenIds++;
        bool _promptsEncrypted = false;
        Agents[tokenIds] = Agent(_name, _description, _model, _userPromptURI, _systemPromptURI, _imageURI, _category, _promptsEncrypted);

        _mint(_recipient, tokenIds);
        collectionIds[_recipient].push(tokenIds);
        _setTokenURI(tokenIds, _tokenURI);
        emit AgentCreated(_name, _description, _model, _category, _recipient, tokenIds);
    }

     /**
     * @dev Update NFT with Encrypted Prompts as token id needed first for encryption params
     *
     * @param _tokenId uint256 Id of the NFT to update
     * @param _encryptedUserPromptURI string Encrypted URI of the Agent's User Prompt
     * @param _encryptedSystemPromptURI string Encrypted URI of the Agent's System Prompt
     */
    function addEncryptedPrompts(uint256 _tokenId, string memory _encryptedUserPromptURI, string memory _encryptedSystemPromptURI) public {
        require(ownerOf(_tokenId) == msg.sender, "Sender must be token owner");
        Agent storage agent = Agents[_tokenId];
        agent.userPromptURI = _encryptedUserPromptURI;
        agent.systemPromptURI = _encryptedSystemPromptURI;
        agent.promptsEncrypted = true;
    }

    /**
     * @dev Return base URI
     * Override {ERC721:_baseURI}
     */
    function _baseURI() internal view override returns (string memory) {
        return baseURI;
    }

    /**
     * @dev Return all token ids owned by address
     * @param _address address Address to check for
     */
    function getCollectionIds(address _address) public view returns (uint256[] memory) {
        return collectionIds[_address];
    }


    /**
     * @dev Remove the given token from collectionIds. 
     *
     * @param from address from
     * @param tokenId tokenId to remove
     */
    function _popId(address from, uint256 tokenId) internal {
        uint256[] storage _collectionIds = collectionIds[from];
        for (uint256 i = 0; i < _collectionIds.length; i++) {
            if (_collectionIds[i] == tokenId) {
                if (i != _collectionIds.length - 1) {
                    _collectionIds[i] = _collectionIds[_collectionIds.length - 1];
                }
                _collectionIds.pop();
                break;
            }
        }
    }

     /**
     * @dev Transfers `tokenId` from `from` to `to`. 
     *
     * Requirements:
     *
     * - `tokenId` token must be owned by `from`.
     *
     * @param from address from
     * @param to address to
     * @param tokenId tokenId to transfer
     */
    function _transfer(
        address from,
        address to,
        uint256 tokenId
    ) internal override {
        super._transfer(from, to, tokenId);
        _popId(from, tokenId);
        collectionIds[to].push(tokenId);
    }

    
}


```



## Security Considerations


## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
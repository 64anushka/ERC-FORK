---
eip: 7625
title: Smart Contract Id's and Metadata Extension
description: Proposes an interface for contractId's and metadata at the smart contract level.
author: Larry V. KÅ‚osowski (@SaulBuilds)
discussions-to: https://ethereum-magicians.org/t/eip-321-smart-contract-id-tokenization-standard/18742
status: Draft
type: Standards Track
category: ERC
created: 2024-02-02
---

## Abstract

This proposal introduces an interface and implementation for contract factory enhancement. Utilizing certain concepts and features from the current nft interface to address the application layer of Ethereum and similar EVM-compatible platforms. This interface aligns with the application, to assign unique identifiers(contractId's), and metadata to the smart contract. Mapping the contractId and managing associated metadata for the deployment adds a layer of accessibility to the underlying asset. The aim is to elevate the discoverability, manageability, and interoperability of smart contracts, furthering their integration into digital marketplaces. This allows for the streamlined transfer of ownership and interaction within a decentralized context. By fostering a more structured approach to contract identification and metadata linkage, the interface seeks to bolster the ecosystem's composability and the efficiency of interactions between decentralized applications, consistent with the ethos of decentralization and open architecture.

## Motivation

The advancement of blockchain technology and the proliferation of decentralized applications (dApps) underscore the need for a dynamic, interoperable protocol for managing smart contracts. A standardized mechanism for tokenization, exchange, and aggregation is necessary. This eip, with its Metadata extension, proposes a structured interface for lifecycle management of smart contracts within marketplaces. from seed to sale. 

## Specification

```solidity
interface IERC321Metadata is IERC321 {
    function tokenURI(uint256 contractId) external view returns (string memory);
}
```
## Rationale

This interface addresses the need for a systematic approach to smart contract tokenization, facilitating the safe sale and transfer of smart contracts on marketplaces. It lays the foundation for an acquisitions market and a legal framework for smart contract sales and trade.

## Backwards Compatibility

the protocol is designed with backward compatibility in mind, ensuring seamless interaction with existing interfaces and the broader Ethereum ecosystem.

## Reference Implementation
The reference implementation provided demonstrate the application of tokenizing and giving identifiers that can be used in collections of assets, contract owners can participate in creating and managing tokenized smart contracts with unique identifiers and metadata.
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.23;

import "lib/openzeppelin-contracts/contracts/access/Ownable.sol";
import "lib/openzeppelin-contracts/contracts/utils/Create2.sol";
import "../interfaces/IERC321Metadata.sol";
import "./templates/ERC721.sol";

contract ContractMarketplace is IERC321Metadata, Ownable {
    uint256 private _nextContractId;
    mapping(uint256 => address) private _contractInstances;
    mapping(uint256 => string) private _metadataURIs;

    constructor() Ownable(msg.sender) {
        _nextContractId = 0;
    }

    function createInstanceWithCreate2(bytes calldata _metadata, bytes32 _salt) 
        external 
        returns (uint256 contractId) 
    {
        require(_metadata.length > 0, "Invalid metadata: Metadata cannot be empty.");
        bytes memory bytecode = abi.encodePacked(type(ERC721Example).creationCode);
        address instance = Create2.deploy(0, _salt, bytecode);
        require(instance != address(0), "Deployment failed: Contract instance could not be deployed.");
        contractId = _nextContractId++;
        _contractInstances[contractId] = instance;
        _metadataURIs[contractId] = string(_metadata);
        emit ContractInstanceCreated(instance, contractId);
    }

    function tokenURI(uint256 contractId) external view override returns (string memory) {
        require(contractId < _nextContractId, "Query for nonexistent contract: This contract ID does not exist.");
        require(_contractInstances[contractId] != address(0), "Contract instance destroyed: The contract has been destroyed and is no longer available.");
        return _metadataURIs[contractId];
    }

    function instanceAddress(uint256 contractId) public view returns (address) {
        require(contractId < _nextContractId, "Query for nonexistent contract: This contract ID does not exist.");
        return _contractInstances[contractId];
    }

    function updateMetadataURI(uint256 contractId, string calldata _newMetadataURI) external onlyOwner {
        require(contractId < _nextContractId, "Update for nonexistent contract: This contract ID does not exist.");
        _metadataURIs[contractId] = _newMetadataURI;
    }

    function destroyContractInstance(uint256 contractId) external onlyOwner {
        require(contractId < _nextContractId, "Destruction of nonexistent contract: This contract ID does not exist.");
        delete _contractInstances[contractId];
        delete _metadataURIs[contractId];
    }

    function createInstance(bytes calldata _metadata) external returns (uint256 contractId) {
        ERC721Example newContract = new ERC721Example();
        address newContractAddress = address(newContract);
        contractId = _nextContractId++;
        _contractInstances[contractId] = newContractAddress;
        _metadataURIs[contractId] = string(_metadata);
        emit ContractInstanceCreated(newContractAddress, contractId);
    }
}
```


## Security Considerations

Securing the implementation of of the contract factory is crucial, focusing on secure management of contract ownership and metadata integrity is important. Adhering to smart contract security best practices, and utilizing CEI pattern where relevant. Opting for decentralized storage solutions for metadata are essential to mitigate risks.

## Copyright

Copyright and related rights waived via CC0.

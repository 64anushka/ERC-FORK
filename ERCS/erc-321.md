---
eip: [erc-321](https://github.com/SaulBuilds/ERCs/blob/master/ERCS/erc-321.md)
title: Smart Contract Id's and Metadata Extension
description: Proposes an interface for contractId's and metadata at the smart contract level.
author: Larry V. KÅ‚osowski (@SaulBuilds)
discussions-to: https://ethereum-magicians.org/t/eip-321-smart-contract-id-tokenization-standard/18742
status: Draft
type: Standards Track
category: ERC
created: 2024-02-02
---

## Abstract

[erc-321](https://github.com/SaulBuilds/ERCs/blob/master/ERCS/erc-321.md) introduces a protocol for the tokenization of smart contracts, facilitating their identification, management, and integration into marketplaces. It outlines the creation of contract instances with unique identifiers(contractId's), alongside ownership and metadata management, to support their sale, purchase, and collection of smart contracts on Ethereum Mainnet and other EVM compatible chains.

## Motivation

The advancement of blockchain technology and the proliferation of decentralized applications (dApps) underscore the need for a dynamic, interoperable protocol for managing smart contracts. A standardized mechanism for tokenization, exchange, and aggregation is necessary. This eip, with its Metadata extension, proposes a structured interface for lifecycle management of smart contracts within marketplaces.

## Specification

```solidity
interface IERC321Metadata is IERC321 {
    function tokenURI(uint256 contractId) external view returns (string memory);
}
```
## Rationale

This interface addresses the need for a systematic approach to smart contract tokenization, facilitating the safe sale and transfer of smart contracts on marketplaces. It lays the foundation for an acquisitions market and a legal framework for smart contract sales and trade.

## Backwards Compatibility

[erc-321](https://github.com/SaulBuilds/ERCs/blob/master/ERCS/erc-321.md) is designed with backward compatibility in mind, ensuring seamless interaction with existing ERC standards and the broader Ethereum ecosystem.

## Reference Implementation
[erc-321](https://github.com/SaulBuilds/ERCs/blob/master/ERCS/erc-321.md) and The reference implementation provided demonstrate the application of tokenizing and giving identifiers that can be used in collections of assets, contract owners can participate in creating and managing tokenized smart contracts with unique identifiers and metadata.
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.23;

import "lib/openzeppelin-contracts/contracts/access/Ownable.sol";
import "lib/openzeppelin-contracts/contracts/utils/Create2.sol";
import "../interfaces/IERC321Metadata.sol";
import "./templates/ERC721.sol";

contract ContractMarketplace is IERC321Metadata, Ownable {
    uint256 private _nextContractId;
    mapping(uint256 => address) private _contractInstances;
    mapping(uint256 => string) private _metadataURIs;

    constructor() Ownable(msg.sender) {
        _nextContractId = 0;
    }

    function createInstanceWithCreate2(bytes calldata _metadata, bytes32 _salt) 
        external 
        returns (uint256 contractId) 
    {
        require(_metadata.length > 0, "Invalid metadata: Metadata cannot be empty.");
        bytes memory bytecode = abi.encodePacked(type(ERC721Example).creationCode);
        address instance = Create2.deploy(0, _salt, bytecode);
        require(instance != address(0), "Deployment failed: Contract instance could not be deployed.");
        contractId = _nextContractId++;
        _contractInstances[contractId] = instance;
        _metadataURIs[contractId] = string(_metadata);
        emit ContractInstanceCreated(instance, contractId);
    }

    function tokenURI(uint256 contractId) external view override returns (string memory) {
        require(contractId < _nextContractId, "Query for nonexistent contract: This contract ID does not exist.");
        require(_contractInstances[contractId] != address(0), "Contract instance destroyed: The contract has been destroyed and is no longer available.");
        return _metadataURIs[contractId];
    }

    function instanceAddress(uint256 contractId) public view returns (address) {
        require(contractId < _nextContractId, "Query for nonexistent contract: This contract ID does not exist.");
        return _contractInstances[contractId];
    }

    function updateMetadataURI(uint256 contractId, string calldata _newMetadataURI) external onlyOwner {
        require(contractId < _nextContractId, "Update for nonexistent contract: This contract ID does not exist.");
        _metadataURIs[contractId] = _newMetadataURI;
    }

    function destroyContractInstance(uint256 contractId) external onlyOwner {
        require(contractId < _nextContractId, "Destruction of nonexistent contract: This contract ID does not exist.");
        delete _contractInstances[contractId];
        delete _metadataURIs[contractId];
    }

    function createInstance(bytes calldata _metadata) external returns (uint256 contractId) {
        ERC721Example newContract = new ERC721Example();
        address newContractAddress = address(newContract);
        contractId = _nextContractId++;
        _contractInstances[contractId] = newContractAddress;
        _metadataURIs[contractId] = string(_metadata);
        emit ContractInstanceCreated(newContractAddress, contractId);
    }
}
```


## Security Considerations

Securing the implementation of [erc-321](https://github.com/SaulBuilds/ERCs/blob/master/ERCS/erc-321.md)is crucial, focusing on managing contract ownership and metadata integrity. Adhering to smart contract security best practices and opting for decentralized storage solutions for metadata are essential to mitigate risks.

## Copyright

Copyright and related rights waived via CC0.
